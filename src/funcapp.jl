module funcapp

	using Plots
	using FastGaussQuadrature
	using FactCheck
	using ApproxFun
	using ApproXD

	# use chebyshev to interpolate this:
	function q1(n)
		f(x) = x .+ 2 .* x.^2 .- exp(-x)
		deg = n-1
		a = -3
		b = 3
		nodes_z, weights = gausschebyshev(n)
		nodes_x = .5 * (a+b) .+ (.5 * (b-a) .* nodes_z)
		y = f(nodes_x)
		n_new = 100
		nodes_new = collect(linspace(a,b,n_new))

		# Get interpolation matrix Phi by calculating each element 1 by 1
		# Chebychev basis polynomials with Chebychev interpolation nodes have the following typical element
		phi(i,j) = cos((n-i+.5) * (j-1) * π/n)
		Phi = Float64[]
		for j in 1:n
	    for i in 1:n
	      push!(Phi,phi(i,j))
	    end
		end
		Phi = reshape(Phi,n,n)

		# solve for coefficients
		c = Phi\y

		# We need a general form for Phi so that we can evaluate it at new nodes generated by linspace
		function T(j,z)
	    if j == 0
	      return 1
	    elseif j == 1
	      return z
	    else
	      return 2z * T(j-1,z) - T(j-2,z)
	    end
		end

		# z-transformation of new nodes:
		z_new = 2 .* (nodes_new .- a)./(b-a) .- 1

		# new Phi matrix
		Phi2 = Float64[]
		for j in 0:deg
	    for z in z_new[1:n_new]
	      push!(Phi2,T(j,z))
	    end
		end
		Phi2 = reshape(Phi2,n_new,deg+1)

		# get approximated values of the original function
		f_approx = Phi2 * reshape(c,15,1)

		# error
		error = f_approx .- f(nodes_new)

		#plot
		#plotlyjs()
		p = plot(f,nodes_new, layout = (1,2), label="true function",xlims=(-3.1,3.1),title="True vs approximated f")
		scatter!(-3:(6/99):3,f_approx,label="chebyshev approximation")
		plot!(p[2],-3:(6/99):3,error,xlims=(-3.1,3.1),ylims =(-1e-9,1e-9), title="Approximation error",legend=false)
		savefig("tereza-q1.png")

		# test
		facts("Are errors close enough to zero?") do
			for i in 1:n_new
				@fact error[i] --> roughly(0,atol=1e-9)
			end
		end
	end

	function q2(n)
		# following the steps from ApproxFun documentation website for interpolating functions at other sets of points
		f(p) = p .+ 2 .* p.^2 .- exp(-p)
		S = Chebyshev(-3..3)
		p = linspace(-3,3,n)
		v = v = p .+ 2 .* p.^2 .- exp(-p)
		V = Array(Float64,n,n)
		for k = 1:n
			V[:,k] = Fun(S,[zeros(k-1);1]).(p)
		end
		approx = Fun(S,V\v)
		#plotlyjs()
		p=plot(f,-3,3,label="true")
		scatter!(p,approx,label="approximation")
		savefig("tereza-q2.png")
	end


	# plot the first 9 basis Chebyshev Polynomial Basis Fnctions
	function q3()

		# Chebyshev polynomial
		function T(j,z)
	    if j == 0
	      return 1
	    elseif j == 1
	      return z
	    else
	      return 2z * T(j-1,z) - T(j-2,z)
	    end
		end

		# Define basis functions
		basis1(z) = T(0,z)
		basis2(z) = T(1,z)
		basis3(z) = T(2,z)
		basis4(z) = T(3,z)
		basis5(z) = T(4,z)
		basis6(z) = T(5,z)
		basis7(z) = T(6,z)
		basis8(z) = T(7,z)
		basis9(z) = T(8,z)

		p = plot(basis1,-1,1,grid=false,layout=(3,3),title="Chebyshev basis functions",ylim=(-1.1,1.1),label="Basis 1",linewidth=2,linecolor=:black)
		plot!(p[2],basis2,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 2",linewidth=2,linecolor=:black)
		plot!(p[3],basis3,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 3",linewidth=2,linecolor=:black)
		plot!(p[4],basis4,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 4",linewidth=2,linecolor=:black)
		plot!(p[5],basis5,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 5",linewidth=2,linecolor=:black)
		plot!(p[6],basis6,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 6",linewidth=2,linecolor=:black)
		plot!(p[7],basis7,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 7",linewidth=2,linecolor=:black)
		plot!(p[8],basis8,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 8",linewidth=2,linecolor=:black)
		plot!(p[9],basis9,-1,1,grid=false,ylim=(-1.1,1.1),label="Basis 9",linewidth=2,linecolor=:black)
		savefig("tereza-q3.png")
	end

	ChebyT(x,deg) = cos(acos(x)*deg)
	unitmap(x,lb,ub) = 2.*(x.-lb)/(ub.-lb) - 1	#[a,b] -> [-1,1]

	type ChebyType
		f::Function # fuction to approximate
		nodes::Union{Vector,LinSpace} # evaluation points
		basis::Matrix # basis evaluated at nodes
		coefs::Vector # estimated coefficients

		deg::Int 	# degree of chebypolynomial
		lb::Float64 # bounds
		ub::Float64

		# constructor
		function ChebyType(_nodes::Union{Vector,LinSpace},_deg,_lb,_ub,_f::Function)
			n = length(_nodes)
			y = _f(_nodes)
			_basis = Float64[ChebyT(unitmap(_nodes[i],_lb,_ub),j) for i=1:n,j=0:_deg]
			_coefs = _basis \ y  # type `?\` to find out more about the backslash operator. depending the args given, it performs a different operation
			# create a ChebyType with those values
			new(_f,_nodes,_basis,_coefs,_deg,_lb,_ub)
		end
	end

	# function to predict points using info stored in ChebyType
	function predict(Ch::ChebyType,x_new)

		true_new = Ch.f(x_new)
		basis_new = Float64[ChebyT(unitmap(x_new[i],Ch.lb,Ch.ub),j) for i=1:length(x_new),j=0:Ch.deg]
		basis_nodes = Float64[ChebyT(unitmap(Ch.nodes[i],Ch.lb,Ch.ub),j) for i=1:length(Ch.nodes),j=0:Ch.deg]
		preds = basis_new * Ch.coefs
		preds_nodes = basis_nodes * Ch.coefs

		return Dict("x"=> x_new,"truth"=>true_new, "preds"=>preds, "preds_nodes" => preds_nodes)
	end

	function q4a(deg=(5,9,15),lb=-5.0,ub=5.0)
		r(x) = 1./(1 + 25 .* x.^2)

		# I. Using uniformly spaced grid
		nodes = linspace(-5,5,deg[1]+1)
		Ch = ChebyType(nodes,deg[1],lb,ub,r)
		x_new = linspace(lb,ub,100)
		p = predict(Ch,x_new)
		#plotlyjs()
		pl = plot(x_new,p["preds"],label="Degree of interpolation: 5",layout=2,ylims=(-.15,.9))
		plot!(pl[1],x_new,r,label="True function",title="Uniform")

		nodes = linspace(-5,5,deg[2]+1)
		Ch = ChebyType(nodes,deg[2],lb,ub,r)
		p = predict(Ch,x_new)
		plot!(pl[1],x_new,p["preds"],label="Degree of interpolation: 9")

		nodes = linspace(-5,5,deg[3]+1)
		Ch = ChebyType(nodes,deg[3],lb,ub,r)
		p = predict(Ch,x_new)
		plot!(pl[1],x_new,p["preds"],label="Degree of interpolation: 15")

		# II. Using Chebyshev nodes
		nodes, w = gausschebyshev(deg[1]+1)
		nodes = .5 * (lb+ub) .+ (.5 * (ub-lb) .* nodes) # interval transformation
		Ch = ChebyType(nodes,deg[1],lb,ub,r) # gives us the basis and coefficients
		p = predict(Ch,x_new)
		plot!(pl[2],x_new,p["preds"],label="Degree of interpolation: 5",title="Chebyshev")
		plot!(pl[2],x_new,r,label="True function")

		nodes, w = gausschebyshev(deg[2]+1)
		nodes = .5 * (lb+ub) .+ (.5 * (ub-lb) .* nodes) # interval transformation
		Ch = ChebyType(nodes,deg[2],lb,ub,r) # gives us the basis and coefficients
		p = predict(Ch,x_new)
		plot!(pl[2],x_new,p["preds"],label="Degree of interpolation: 9")

		nodes, w = gausschebyshev(deg[3]+1)
		nodes = .5 * (lb+ub) .+ (.5 * (ub-lb) .* nodes) # interval transformation
		Ch = ChebyType(nodes,deg[3],lb,ub,r) # gives us the basis and coefficients
		p = predict(Ch,x_new)
		plot!(pl[2],x_new,p["preds"],label="Degree of interpolation: 15")
		savefig("tereza-q4a.png")
	end

	function q4b()
		r(x) = 1./(1 + 25 .* x.^2)

		bs1 = BSpline(13,3,-5,5) # using 13 equidistant knots on (-5,5)

		random = rand(5)
		my_knots = vcat(-5,sort(-random), 0.0, sort(random),5)

		bs2 = BSpline(my_knots,3) # using knots concentrated towards zero

		nodes = collect(linspace(-5,5.0,65))

		# getting coefficients
		c1 = getBasis(nodes,bs1) \ r(nodes)
		c2 = getBasis(nodes,bs2) \ r(nodes)

		nodes_new = collect(linspace(-5,5.0,100)) # choose new nodes to see how good is the approximation
		True = r(nodes_new)
		approx1 = getBasis(nodes_new,bs1) * c1
		approx2 = getBasis(nodes_new,bs2) * c2
		error1 = True .- approx1
		error2 = True .- approx2

		# plot
		#plotlyjs()
		p = plot(r,nodes_new,layout=2,label="runge",xlims=(-5.1,5.1),leg=false)
		plot!(p[1],title="original function")
		plot!(p[2],-5:10/99:5,error1,label="equidistant",title="errors",ylims=(-.4,.4),color=:green)
		plot!(p[2],-5:10/99:5,error2,label="concentrated")
		scatter!(p[2],my_knots,zeros(13),label="concentrated knots",color=:red)
		scatter!(p[2],bs1.knots[4:16],0.1*ones(13),label="equidistant knots",color=:black)
		savefig("tereza-q4b.png")
	end

	function q5()
		f(x) = abs(x).^.5
		pl = plot(f,-1,1,layout=3,title="True fucntion")
		nodes = collect(linspace(-1,1,65))

		# Uniform
		bs1 = BSpline(13,3,-1,1)
		c1 = getBasis(nodes,bs1) \ f(nodes)

		# Multiplicity at zero
		multi = vcat(linspace(-1,-0.1,5),-0.0001,0,0.0001,	linspace(0.1,1,5))
		bs2 = BSpline(multi,3)
		c2 = getBasis(nodes,bs2) \ f(nodes)

		# Approximations
		nodes_new = collect(linspace(-1,1,100))
		approx1 = getBasis(nodes_new,bs1) * c1
		approx2 = getBasis(nodes_new,bs2) * c2
		e1 = f(nodes_new) .- approx1
		e2 = f(nodes_new) .- approx2

		#plotlyjs()
		plot!(pl[2],nodes_new,approx1,label="Spline with uniform knots",title="Spline approximations")
		plot!(pl[2],nodes_new,approx2,label="Spline with knots with multiplicity at zero")
		plot!(pl[3], nodes_new,e1,label="Error - uniform knots",title="Errors")
		plot!(pl[3], nodes_new,e2,label="Error - knots with multiplicity at zero")
		savefig("tereza-q5.png")
	end


	# function to run all questions
	function runall()
		println("running all questions of HW-funcapprox:")
		q1(15)
		q2(15)
		q3()
		q4a()
		q4b()
		q5()
		println("end of homework")
	end


end
